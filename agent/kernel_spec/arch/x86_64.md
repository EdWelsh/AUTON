# x86_64 Architecture Specification

## Overview

This document is the definitive reference for agent code generators building the x86_64 HAL implementation for the AUTON kernel. It specifies every architecture-specific detail: boot protocol, register layout, page table format, memory map, hardware programming interfaces, and assembly routines. All addresses, bit positions, port numbers, and register names are authoritative. When in doubt, this file is the source of truth for x86_64.

Target: AMD64 (Intel 64 / x86-64) in long mode (IA-32e mode, 64-bit sub-mode).

---

## Boot Protocol

### Multiboot2 (GRUB-Compatible)

The kernel is loaded by a Multiboot2-compliant bootloader (GRUB2). The bootloader places the CPU in 32-bit protected mode with paging disabled, A20 enabled, and interrupts disabled.

| Field | Value |
|-------|-------|
| Magic number | `0xE85250D6` |
| Architecture | `0` (i386 / protected mode) |
| Header length | Computed from header start to end |
| Checksum | `-(magic + architecture + header_length)` truncated to 32 bits |

On entry from GRUB:

| Register | Contents |
|----------|----------|
| EAX | Multiboot2 boot magic: `0x36D76289` |
| EBX | Physical address of the Multiboot2 information structure |
| CS | 32-bit read/execute code segment |
| DS, ES, FS, GS, SS | 32-bit read/write data segment |
| ESP | Undefined (kernel must set its own stack immediately) |
| CR0 | PE=1 (protected mode), PG=0 (paging off) |
| EFLAGS.IF | 0 (interrupts disabled) |

### Entry Point and Long Mode Transition

The kernel entry point `_start` executes in 32-bit protected mode. It must:

1. Validate EAX == `0x36D76289` (Multiboot2 magic). If invalid, halt with `hlt` loop.
2. Save EBX (Multiboot2 info pointer) to a known memory location.
3. Set up a temporary 32-bit stack.
4. Build initial page tables (identity map first 2MB + higher-half mapping).
5. Load PML4 physical address into CR3.
6. Enable PAE in CR4 (bit 5).
7. Enable Long Mode by setting EFER.LME (bit 8) via MSR `0xC0000080`.
8. Enable paging by setting CR0.PG (bit 31).
9. Far jump to 64-bit code segment to enter `_start64`.

In `_start64` (now in 64-bit long mode):

1. Load the 64-bit GDT.
2. Reload all segment registers (DS, ES, FS, GS, SS = `0x10` kernel data selector).
3. Set RSP to top of a 16KB kernel boot stack.
4. Clear the BSS section (`rep stosb` with RCX = BSS size, RDI = BSS start).
5. Move the saved Multiboot2 info pointer into RDI (first argument per System V ABI).
6. Call `kernel_main`.

### GDT Layout

6 logical entries (the TSS descriptor occupies two 8-byte slots):

| Index | Selector | Access Byte | Granularity | Description |
|-------|----------|-------------|-------------|-------------|
| 0 | `0x00` | `0x00` | `0x00` | Null descriptor (required) |
| 1 | `0x08` | `0x9A` | `0xAF` | Kernel code segment, 64-bit, DPL 0, execute/read |
| 2 | `0x10` | `0x92` | `0x00` | Kernel data segment, DPL 0, read/write |
| 3 | `0x18` | `0xFA` | `0xAF` | User code segment, 64-bit, DPL 3, execute/read |
| 4 | `0x20` | `0xF2` | `0x00` | User data segment, DPL 3, read/write |
| 5 | `0x28` | `0x89` | `0x00` | TSS descriptor (16 bytes, spans slots 5-6) |

Access byte bit layout (for code/data segments):
- Bit 7: Present (P) = 1
- Bits 6-5: Descriptor Privilege Level (DPL)
- Bit 4: Descriptor type (S) = 1 for code/data
- Bit 3: Executable (E) = 1 for code, 0 for data
- Bit 2: Direction/Conforming
- Bit 1: Readable (code) / Writable (data)
- Bit 0: Accessed

Granularity byte for 64-bit code segments:
- Bit 5 (L): Long mode = 1
- Bit 6 (D/B): Default operand size = 0 (must be 0 when L=1)
- Bit 7 (G): Granularity (irrelevant in long mode)

### IDT Layout

256 entries, each 16 bytes in long mode:

| Vector(s) | Type | Description |
|-----------|------|-------------|
| 0 | Trap | #DE Division Error |
| 1 | Trap | #DB Debug Exception |
| 2 | Interrupt | NMI Non-Maskable Interrupt |
| 3 | Trap | #BP Breakpoint |
| 4 | Trap | #OF Overflow |
| 5 | Trap | #BR Bound Range Exceeded |
| 6 | Trap | #UD Invalid Opcode |
| 7 | Trap | #NM Device Not Available |
| 8 | Trap | #DF Double Fault (uses IST1, error code = 0) |
| 9 | Trap | Coprocessor Segment Overrun (reserved) |
| 10 | Trap | #TS Invalid TSS (error code) |
| 11 | Trap | #NP Segment Not Present (error code) |
| 12 | Trap | #SS Stack-Segment Fault (error code) |
| 13 | Trap | #GP General Protection Fault (error code) |
| 14 | Trap | #PF Page Fault (error code; CR2 = faulting address) |
| 15 | -- | Reserved |
| 16 | Trap | #MF x87 Floating-Point Exception |
| 17 | Trap | #AC Alignment Check (error code) |
| 18 | Trap | #MC Machine Check |
| 19 | Trap | #XM SIMD Floating-Point Exception |
| 20 | Trap | #VE Virtualization Exception |
| 21 | Trap | #CP Control Protection Exception (error code) |
| 22-31 | -- | Reserved |
| 32 | Interrupt | IRQ 0 - PIT Timer |
| 33 | Interrupt | IRQ 1 - PS/2 Keyboard |
| 34 | Interrupt | IRQ 2 - PIC Cascade (internal, never fires) |
| 35 | Interrupt | IRQ 3 - COM2 / COM4 |
| 36 | Interrupt | IRQ 4 - COM1 / COM3 |
| 37 | Interrupt | IRQ 5 - LPT2 / Sound Card |
| 38 | Interrupt | IRQ 6 - Floppy Disk |
| 39 | Interrupt | IRQ 7 - LPT1 / Spurious |
| 40 | Interrupt | IRQ 8 - CMOS RTC |
| 41 | Interrupt | IRQ 9 - Free / ACPI |
| 42 | Interrupt | IRQ 10 - Free |
| 43 | Interrupt | IRQ 11 - Free |
| 44 | Interrupt | IRQ 12 - PS/2 Mouse |
| 45 | Interrupt | IRQ 13 - FPU / Coprocessor |
| 46 | Interrupt | IRQ 14 - Primary ATA |
| 47 | Interrupt | IRQ 15 - Secondary ATA |
| 48-255 | -- | Available for software interrupts, MSI, APIC |

IDT gate descriptor format (16 bytes):

```
Bits   [15:0]   offset_low      Offset bits 0-15
Bits   [31:16]  selector        Code segment selector (0x08 for kernel code)
Bits   [34:32]  ist             IST index (0 = no IST)
Bits   [39:35]  reserved        Must be zero
Bits   [43:40]  type            0xE = 64-bit interrupt gate, 0xF = 64-bit trap gate
Bits   [44]     zero            Must be zero
Bits   [46:45]  dpl             Descriptor Privilege Level
Bits   [47]     present         1 = present
Bits   [63:48]  offset_mid      Offset bits 16-31
Bits   [95:64]  offset_high     Offset bits 32-63
Bits   [127:96] reserved        Must be zero
```

Interrupt gates automatically clear IF (disabling further interrupts). Trap gates leave IF unchanged.

### Multiboot2 Header (NASM)

```nasm
section .multiboot2
align 8
mb2_header_start:
    dd 0xE85250D6                                       ; magic
    dd 0                                                ; architecture: i386 (0)
    dd mb2_header_end - mb2_header_start                ; header length
    dd -(0xE85250D6 + 0 + (mb2_header_end - mb2_header_start)) ; checksum (uint32 wrap)

    ; --- Framebuffer request tag ---
    align 8
    dw 5                ; type: framebuffer
    dw 0                ; flags: optional (bit 0 = 0)
    dd 20               ; size
    dd 0                ; width  (0 = no preference)
    dd 0                ; height (0 = no preference)
    dd 0                ; depth  (0 = no preference)

    ; --- Module alignment tag ---
    align 8
    dw 6                ; type: module alignment
    dw 0                ; flags
    dd 8                ; size

    ; --- End tag ---
    align 8
    dw 0                ; type: end
    dw 0                ; flags
    dd 8                ; size
mb2_header_end:
```

### Boot Assembly Skeleton (`boot.asm`)

```nasm
; =============================================================================
; boot.asm - AUTON kernel x86_64 boot entry
; Multiboot2 -> 32-bit protected mode -> 64-bit long mode -> kernel_main()
; =============================================================================

bits 32

; External symbols from linker script
extern _kernel_start
extern _kernel_end
extern _bss_start
extern _bss_end
extern kernel_main

; Multiboot2 header (see section above)
section .multiboot2
align 8
mb2_header_start:
    dd 0xE85250D6
    dd 0
    dd mb2_header_end - mb2_header_start
    dd -(0xE85250D6 + 0 + (mb2_header_end - mb2_header_start))
    align 8
    dw 5, 0
    dd 20
    dd 0, 0, 0
    align 8
    dw 6, 0
    dd 8
    align 8
    dw 0, 0
    dd 8
mb2_header_end:

; =============================================================================
; 32-bit entry point
; =============================================================================
section .text
global _start
_start:
    ; --- Validate Multiboot2 magic ---
    cmp eax, 0x36D76289
    jne .no_multiboot

    ; --- Save Multiboot2 info pointer ---
    mov [mb2_info_ptr], ebx

    ; --- Set up 32-bit stack ---
    mov esp, stack_top_32

    ; --- Build initial page tables ---
    ; Zero all page table memory
    mov edi, pml4
    xor eax, eax
    mov ecx, (4096 * 4) / 4     ; 4 tables * 4096 bytes / 4 bytes per stosd
    rep stosd

    ; PML4[0] -> PDPT (identity map, low)
    mov eax, pdpt
    or  eax, 0x03               ; PRESENT | WRITABLE
    mov [pml4], eax

    ; PML4[256] -> PDPT (higher-half at 0xFFFF800000000000)
    ; PML4 index for 0xFFFF800000000000 = (addr >> 39) & 0x1FF = 256
    mov [pml4 + 256 * 8], eax

    ; PDPT[0] -> PD
    mov eax, pd
    or  eax, 0x03               ; PRESENT | WRITABLE
    mov [pdpt], eax

    ; PD[0] -> 2MB huge page at physical 0x0
    mov dword [pd], 0x00000083  ; PRESENT | WRITABLE | HUGE (bit 7)
    mov dword [pd + 4], 0       ; upper 32 bits = 0

    ; --- Load PML4 into CR3 ---
    mov eax, pml4
    mov cr3, eax

    ; --- Enable PAE (CR4 bit 5) ---
    mov eax, cr4
    or  eax, (1 << 5)           ; PAE
    mov cr4, eax

    ; --- Enable Long Mode (EFER.LME, MSR 0xC0000080 bit 8) ---
    mov ecx, 0xC0000080         ; IA32_EFER MSR
    rdmsr
    or  eax, (1 << 8)           ; LME = Long Mode Enable
    wrmsr

    ; --- Enable paging (CR0 bit 31) and write-protect (bit 16) ---
    mov eax, cr0
    or  eax, (1 << 31) | (1 << 16)  ; PG | WP
    mov cr0, eax

    ; --- Load temporary 64-bit GDT and far jump to long mode ---
    lgdt [gdt32_ptr]
    jmp 0x08:.long_mode_entry   ; selector 0x08 = 64-bit code segment

.no_multiboot:
    ; Invalid magic - halt
    cli
    hlt
    jmp .no_multiboot

; =============================================================================
; 64-bit entry point
; =============================================================================
bits 64
.long_mode_entry:
global _start64
_start64:
    ; --- Reload segment registers with kernel data selector ---
    mov ax, 0x10                ; selector 0x10 = kernel data
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax

    ; --- Set up 64-bit kernel stack (16KB) ---
    mov rsp, stack_top

    ; --- Clear BSS ---
    mov rdi, _bss_start
    mov rcx, _bss_end
    sub rcx, _bss_start
    xor al, al
    rep stosb

    ; --- Call kernel_main(multiboot2_info_phys) ---
    xor rdi, rdi
    mov edi, [mb2_info_ptr]     ; zero-extend 32-bit address into RDI
    call kernel_main

    ; --- Should not return. Halt if it does. ---
    cli
.halt_loop:
    hlt
    jmp .halt_loop

; =============================================================================
; Data: saved Multiboot2 info pointer
; =============================================================================
section .data
mb2_info_ptr: dd 0

; =============================================================================
; Temporary 64-bit GDT (minimal, replaced by full GDT in C)
; =============================================================================
section .rodata
align 16
gdt32_start:
    dq 0x0000000000000000       ; null descriptor
    dq 0x00AF9A000000FFFF       ; 64-bit code: base=0, limit=0xFFFFF, L=1, P=1, DPL=0
    dq 0x00CF92000000FFFF       ; data: base=0, limit=0xFFFFF, P=1, DPL=0, W=1
gdt32_end:

gdt32_ptr:
    dw gdt32_end - gdt32_start - 1
    dq gdt32_start

; =============================================================================
; Page tables (must be page-aligned)
; =============================================================================
section .bss
align 4096
pml4:   resb 4096
pdpt:   resb 4096
pd:     resb 4096
pt:     resb 4096               ; reserved for 4KB page table if needed later

; =============================================================================
; Kernel boot stack (16KB)
; =============================================================================
align 16
stack_bottom:
    resb 16384
stack_top:

; 32-bit temporary stack (small, only used during mode transition)
align 4
stack_bottom_32:
    resb 4096
stack_top_32:
```

---

## Toolchain

| Tool | Binary | Purpose |
|------|--------|---------|
| C Compiler | `x86_64-elf-gcc` | Freestanding cross-compiler targeting bare-metal x86_64 ELF |
| Assembler | `nasm` | Netwide Assembler for x86_64 assembly files |
| Linker | `x86_64-elf-ld` | GNU linker for ELF64 output |
| Objcopy | `x86_64-elf-objcopy` | Binary extraction and format conversion |

### Compiler Flags

```makefile
CC      = x86_64-elf-gcc
AS      = nasm
LD      = x86_64-elf-ld

CFLAGS  = -ffreestanding       \  # No hosted standard library
          -mno-red-zone        \  # Disable 128-byte red zone (unsafe in kernel, interrupts clobber it)
          -fno-exceptions      \  # No C++ exceptions
          -fno-rtti            \  # No C++ RTTI
          -mcmodel=kernel      \  # Assume code runs in upper 2GB of address space (allows sign-extended 32-bit addresses)
          -Wall -Wextra        \  # All warnings
          -std=c11             \  # C11 standard
          -fno-stack-protector \  # No stack canary (no __stack_chk_fail in freestanding)
          -fno-pic             \  # No position-independent code
          -mno-sse             \  # Disable SSE (not yet initialized in early boot)
          -mno-mmx             \  # Disable MMX
          -mno-sse2               # Disable SSE2

ASFLAGS = -f elf64                # Output format: 64-bit ELF

LDFLAGS = -T linker.ld         \  # Custom linker script
          -nostdlib            \  # No standard library
          -z max-page-size=4096   # 4KB page alignment
```

### Linker Script Skeleton (`linker.ld`)

```ld
ENTRY(_start)
OUTPUT_FORMAT(elf64-x86-64)

KERNEL_VBASE = 0xFFFF800000000000;
KERNEL_PHYS  = 0x100000;

SECTIONS
{
    . = KERNEL_PHYS;

    .multiboot2 : { *(.multiboot2) }

    .text ALIGN(4096) : AT(ADDR(.text))
    {
        _text_start = .;
        *(.text .text.*)
        _text_end = .;
    }

    .rodata ALIGN(4096) : AT(ADDR(.rodata))
    {
        _rodata_start = .;
        *(.rodata .rodata.*)
        _rodata_end = .;
    }

    .data ALIGN(4096) : AT(ADDR(.data))
    {
        _data_start = .;
        *(.data .data.*)
        _data_end = .;
    }

    .bss ALIGN(4096) : AT(ADDR(.bss))
    {
        _bss_start = .;
        *(.bss .bss.*)
        *(COMMON)
        _bss_end = .;
    }

    _kernel_start = KERNEL_PHYS;
    _kernel_end = .;
}
```

---

## Register Set

### General Purpose Registers (64-bit)

| Register | Width | Purpose |
|----------|-------|---------|
| RAX | 64 | Accumulator, return value, syscall number |
| RBX | 64 | Base register (callee-saved) |
| RCX | 64 | Counter, 4th argument (System V ABI) |
| RDX | 64 | Data, 3rd argument, I/O port operand |
| RSI | 64 | Source index, 2nd argument |
| RDI | 64 | Destination index, 1st argument |
| RBP | 64 | Frame pointer (callee-saved) |
| RSP | 64 | Stack pointer |
| R8 | 64 | 5th argument |
| R9 | 64 | 6th argument |
| R10 | 64 | Temporary (caller-saved) |
| R11 | 64 | Temporary (caller-saved) |
| R12 | 64 | Callee-saved |
| R13 | 64 | Callee-saved |
| R14 | 64 | Callee-saved |
| R15 | 64 | Callee-saved |

Sub-registers: EAX (32-bit), AX (16-bit), AH/AL (8-bit high/low). Writing a 32-bit register zero-extends into the 64-bit register. Writing a 16-bit or 8-bit register preserves upper bits.

### System / Control Registers

| Register | Purpose |
|----------|---------|
| CR0 | Contains PE (bit 0, protected mode), WP (bit 16, write protect), PG (bit 31, paging) |
| CR2 | Contains the linear address that caused the most recent page fault |
| CR3 | Contains the physical address of the PML4 table (address space root). Writing CR3 flushes the TLB (non-global entries). |
| CR4 | Contains PAE (bit 5), PGE (bit 7, global pages), OSFXSR (bit 9), OSXMMEXCPT (bit 10) |
| RFLAGS | Status/control: CF(0), PF(2), AF(4), ZF(6), SF(7), TF(8), IF(9), DF(10), OF(11), IOPL(12-13) |
| MSR 0xC0000080 | IA32_EFER: SCE(0, syscall enable), LME(8, long mode enable), LMA(10, long mode active), NXE(11, no-execute enable) |

### Calling Convention (System V AMD64 ABI)

This is the mandatory calling convention for all C code compiled by `x86_64-elf-gcc`:

| Argument # | Register | Notes |
|------------|----------|-------|
| 1st | RDI | |
| 2nd | RSI | |
| 3rd | RDX | |
| 4th | RCX | |
| 5th | R8 | |
| 6th | R9 | |
| 7th+ | Stack | Pushed right-to-left |
| Return | RAX | 128-bit return in RAX:RDX |

**Caller-saved (volatile):** RAX, RCX, RDX, RSI, RDI, R8, R9, R10, R11

**Callee-saved (non-volatile):** RBX, RBP, R12, R13, R14, R15

**Stack alignment:** The stack must be 16-byte aligned **before** the `CALL` instruction. Since `CALL` pushes an 8-byte return address, the stack is 16-byte aligned at function entry minus 8. Functions that call other functions must adjust accordingly.

---

## Page Table Format

### 4-Level Paging

x86_64 uses 4-level page tables when CR4.LA57 is clear (48-bit virtual addresses):

```
Virtual Address (48 bits, sign-extended to 64 bits):
┌──────────┬──────────┬──────────┬──────────┬──────────────┐
│ PML4 idx │ PDPT idx │  PD idx  │  PT idx  │   Offset     │
│ [47:39]  │ [38:30]  │ [29:21]  │ [20:12]  │   [11:0]     │
│  9 bits  │  9 bits  │  9 bits  │  9 bits  │   12 bits    │
└──────────┴──────────┴──────────┴──────────┴──────────────┘
```

| Level | Name | Input Bits | Entries | Entry Size | Table Size |
|-------|------|------------|---------|------------|------------|
| 4 (root) | PML4 (Page Map Level 4) | [47:39] | 512 | 8 bytes | 4096 bytes |
| 3 | PDPT (Page Directory Pointer Table) | [38:30] | 512 | 8 bytes | 4096 bytes |
| 2 | PD (Page Directory) | [29:21] | 512 | 8 bytes | 4096 bytes |
| 1 | PT (Page Table) | [20:12] | 512 | 8 bytes | 4096 bytes |

### Page Sizes

| Page Size | Mechanism | Offset Bits |
|-----------|-----------|-------------|
| 4 KB | PT entry (normal) | 12 bits |
| 2 MB | PD entry with HUGE bit set (PS=1) | 21 bits |
| 1 GB | PDPT entry with HUGE bit set (PS=1) | 30 bits |

### Page Table Entry Flags

```c
#define PTE_PRESENT      (1ULL << 0)   /* P: page is present in memory */
#define PTE_WRITABLE     (1ULL << 1)   /* R/W: 0=read-only, 1=read/write */
#define PTE_USER         (1ULL << 2)   /* U/S: 0=supervisor-only, 1=user accessible */
#define PTE_WRITETHROUGH (1ULL << 3)   /* PWT: write-through caching */
#define PTE_NOCACHE      (1ULL << 4)   /* PCD: disable caching */
#define PTE_ACCESSED     (1ULL << 5)   /* A: set by CPU on any access */
#define PTE_DIRTY        (1ULL << 6)   /* D: set by CPU on write (leaf entries only) */
#define PTE_HUGE         (1ULL << 7)   /* PS: page size - 2MB at PD level, 1GB at PDPT level */
#define PTE_GLOBAL       (1ULL << 8)   /* G: global page, not flushed on CR3 load (requires CR4.PGE=1) */
/* Bits 9-11: Available for OS use */
/* Bits 12-51: Physical address (40 bits, aligned to page size) */
/* Bits 52-62: Available for OS use */
#define PTE_NO_EXECUTE   (1ULL << 63)  /* NX: no-execute (requires EFER.NXE=1) */

/* Mask to extract the physical address from any PTE */
#define PTE_ADDR_MASK    0x000FFFFFFFFFF000ULL
```

Bit layout of a 4KB page table entry:

```
Bit  63    : NX (No Execute)
Bits 62-52 : Available for OS
Bits 51-12 : Physical page frame address (4KB aligned)
Bits 11-9  : Available for OS
Bit  8     : G (Global)
Bit  7     : PAT (for PT level) / PS (for PD/PDPT level)
Bit  6     : D (Dirty)
Bit  5     : A (Accessed)
Bit  4     : PCD (Page Cache Disable)
Bit  3     : PWT (Page Write-Through)
Bit  2     : U/S (User/Supervisor)
Bit  1     : R/W (Read/Write)
Bit  0     : P (Present)
```

### TLB Management

| Operation | Instruction | Effect |
|-----------|-------------|--------|
| Flush single entry | `invlpg [address]` | Invalidates the TLB entry for the page containing `address` |
| Flush all (non-global) | Write to CR3 | Reloading CR3 flushes all non-global TLB entries |
| Flush all (including global) | Toggle CR4.PGE | Clear PGE, then set it again to flush global entries |
| Switch address space | `mov cr3, <pml4_phys>` | Loads new PML4 and flushes TLB |

Inline assembly for TLB invalidation:

```c
static inline void invlpg(uint64_t addr)
{
    __asm__ volatile("invlpg (%0)" : : "r"(addr) : "memory");
}

static inline void load_cr3(uint64_t pml4_phys)
{
    __asm__ volatile("mov %0, %%cr3" : : "r"(pml4_phys) : "memory");
}

static inline uint64_t read_cr3(void)
{
    uint64_t val;
    __asm__ volatile("mov %%cr3, %0" : "=r"(val));
    return val;
}
```

---

## Memory Layout

### Virtual Address Space

```
0x0000_0000_0000_0000 ┬──────────────────────────────────────────────┐
                       │  User space                                  │
                       │  Per-process, switched via CR3                │
0x0000_7FFF_FFFF_FFFF ┴──────────────────────────────────────────────┘
                       ← Non-canonical hole (addresses with bits 47    →
                       ← and 63 disagreeing cause #GP)                 →
0xFFFF_8000_0000_0000 ┬──────────────────────────────────────────────┐
                       │  Kernel space (higher-half)                   │
                       │  Same mapping in all address spaces           │
                       │  KERNEL_VBASE = 0xFFFF800000000000            │
0xFFFF_FFFF_FFFF_FFFF ┴──────────────────────────────────────────────┘
```

### Physical Memory Layout

| Start Address | Size | Region |
|---------------|------|--------|
| `0x0000_0000` | 1 MB | Legacy BIOS area (real-mode IVT, BDA, EBDA, VGA, ROM). Reserved, do not allocate. |
| `0x0010_0000` | ~1 MB | Kernel image load address. GRUB loads the kernel ELF here. |
| `0x0020_0000` | Variable | Kernel heap start. Managed by slab allocator after `slab_init()`. |
| `0x0040_0000` | 4-256 MB | SLM memory pool. Size determined by available RAM at boot. |
| `0x0080_0000` | Variable | Process memory pool. Physical pages allocated on demand by PMM. |
| `0x000B_8000` | 4000 bytes | VGA text mode framebuffer (80x25, 2 bytes/char). |
| `0x000E_0000` - `0x000F_FFFF` | 128 KB | BIOS ROM area. ACPI RSDP search range. |

### Architecture Constants

```c
#define ARCH_PAGE_SIZE       4096
#define ARCH_PAGE_SHIFT      12
#define ARCH_PT_LEVELS       4
#define ARCH_STACK_SIZE      16384       /* 16KB kernel stack per process */

#define KERNEL_VBASE         0xFFFF800000000000ULL
#define KERNEL_PHYS_LOAD     0x0000000000100000ULL   /* 1 MB */
#define KERNEL_HEAP_START    0x0000000000200000ULL   /* 2 MB */
#define SLM_POOL_BASE_PHYS   0x0000000000400000ULL   /* 4 MB */
#define PROCESS_MEM_START    0x0000000000800000ULL   /* 8 MB */

#define USER_SPACE_START     0x0000000000000000ULL
#define USER_SPACE_END       0x00007FFFFFFFFFFFULL
#define KERNEL_SPACE_START   0xFFFF800000000000ULL
#define KERNEL_SPACE_END     0xFFFFFFFFFFFFFFFFULL
```

---

## I/O Mechanism

### Port I/O (PIO)

x86_64 retains legacy port I/O via dedicated `in` and `out` instructions. Port addresses occupy a separate 16-bit address space (0x0000-0xFFFF), independent of memory addresses.

```c
static inline uint8_t inb(uint16_t port)
{
    uint8_t val;
    __asm__ volatile("inb %1, %0" : "=a"(val) : "Nd"(port));
    return val;
}

static inline void outb(uint16_t port, uint8_t val)
{
    __asm__ volatile("outb %0, %1" : : "a"(val), "Nd"(port));
}

static inline uint16_t inw(uint16_t port)
{
    uint16_t val;
    __asm__ volatile("inw %1, %0" : "=a"(val) : "Nd"(port));
    return val;
}

static inline void outw(uint16_t port, uint16_t val)
{
    __asm__ volatile("outw %0, %1" : : "a"(val), "Nd"(port));
}

static inline uint32_t inl(uint16_t port)
{
    uint32_t val;
    __asm__ volatile("inl %1, %0" : "=a"(val) : "Nd"(port));
    return val;
}

static inline void outl(uint16_t port, uint32_t val)
{
    __asm__ volatile("outl %0, %1" : : "a"(val), "Nd"(port));
}

/* I/O wait: short delay for slow ISA devices (write to unused port 0x80) */
static inline void io_wait(void)
{
    __asm__ volatile("outb %%al, $0x80" : : "a"(0));
}
```

### Memory-Mapped I/O (MMIO)

Device registers mapped into the physical address space. Must be accessed through volatile pointers after VMM mapping with `PTE_NOCACHE` to prevent CPU caching.

```c
static inline uint32_t mmio_read32(volatile void *addr)
{
    return *(volatile uint32_t *)addr;
}

static inline void mmio_write32(volatile void *addr, uint32_t val)
{
    *(volatile uint32_t *)addr = val;
}
```

### PCI Configuration Space

**Legacy mechanism (type 1) via port I/O:**

| Port | Width | Purpose |
|------|-------|---------|
| `0xCF8` | 32-bit | CONFIG_ADDRESS: bus/device/function/offset selector |
| `0xCFC` | 32-bit | CONFIG_DATA: read/write the selected register |

CONFIG_ADDRESS format (32 bits):

```
Bit  31      : Enable (must be 1)
Bits 30-24   : Reserved
Bits 23-16   : Bus number (0-255)
Bits 15-11   : Device number (0-31)
Bits 10-8    : Function number (0-7)
Bits 7-2     : Register offset (DWORD-aligned, bits [1:0] = 0)
Bits 1-0     : Must be 0
```

```c
uint32_t pci_config_read32(uint8_t bus, uint8_t dev, uint8_t func, uint8_t offset)
{
    uint32_t address = (1U << 31)          /* enable bit */
                     | ((uint32_t)bus << 16)
                     | ((uint32_t)dev << 11)
                     | ((uint32_t)func << 8)
                     | (offset & 0xFC);    /* DWORD-aligned */
    outl(0xCF8, address);
    return inl(0xCFC);
}

void pci_config_write32(uint8_t bus, uint8_t dev, uint8_t func, uint8_t offset, uint32_t val)
{
    uint32_t address = (1U << 31)
                     | ((uint32_t)bus << 16)
                     | ((uint32_t)dev << 11)
                     | ((uint32_t)func << 8)
                     | (offset & 0xFC);
    outl(0xCF8, address);
    outl(0xCFC, val);
}
```

**PCIe ECAM (Enhanced Configuration Access Mechanism):**

Modern PCIe uses MMIO-based configuration. The base address of the ECAM region is found in the ACPI MCFG table. Each function gets a 4KB region:

```
ECAM address = ECAM_base + (bus << 20) | (device << 15) | (function << 12) | register_offset
```

---

## Core Hardware

### 8259A PIC (Programmable Interrupt Controller)

Dual-PIC cascade: master (IRQ 0-7) and slave (IRQ 8-15).

| Port | PIC | Purpose |
|------|-----|---------|
| `0x20` | Master | Command register |
| `0x21` | Master | Data register (IMR) |
| `0xA0` | Slave | Command register |
| `0xA1` | Slave | Data register (IMR) |

**Initialization sequence (remap IRQs to vectors 32-47):**

```c
void pic_init(void)
{
    /* ICW1: begin initialization, expect ICW4 */
    outb(0x20, 0x11);   /* master command */
    io_wait();
    outb(0xA0, 0x11);   /* slave command */
    io_wait();

    /* ICW2: set vector offsets */
    outb(0x21, 0x20);   /* master: IRQ 0-7  -> vectors 32-39 (0x20) */
    io_wait();
    outb(0xA1, 0x28);   /* slave:  IRQ 8-15 -> vectors 40-47 (0x28) */
    io_wait();

    /* ICW3: tell master about slave on IRQ2, tell slave its cascade identity */
    outb(0x21, 0x04);   /* master: slave on IRQ2 (bit 2) */
    io_wait();
    outb(0xA1, 0x02);   /* slave: cascade identity 2 */
    io_wait();

    /* ICW4: 8086 mode */
    outb(0x21, 0x01);
    io_wait();
    outb(0xA1, 0x01);
    io_wait();

    /* Mask all IRQs initially (unmask individually as drivers register) */
    outb(0x21, 0xFF);
    outb(0xA1, 0xFF);
}
```

**End-of-Interrupt (EOI):**

```c
void pic_send_eoi(uint8_t irq)
{
    if (irq >= 8) {
        outb(0xA0, 0x20);   /* EOI to slave */
    }
    outb(0x20, 0x20);       /* EOI to master (always) */
}
```

**Unmask a specific IRQ:**

```c
void pic_unmask(uint8_t irq)
{
    uint16_t port;
    if (irq < 8) {
        port = 0x21;
    } else {
        port = 0xA1;
        irq -= 8;
    }
    uint8_t mask = inb(port);
    mask &= ~(1 << irq);
    outb(port, mask);
}
```

### APIC (Advanced Programmable Interrupt Controller)

Used for multi-processor systems. Consists of a Local APIC per CPU core and one or more I/O APICs.

**Local APIC:**
- Memory-mapped at `0xFEE00000` (default, can be relocated via IA32_APIC_BASE MSR `0x1B`).
- Key registers (offsets from APIC base):

| Offset | Register | Purpose |
|--------|----------|---------|
| `0x020` | ID | Local APIC ID |
| `0x030` | Version | APIC version |
| `0x080` | TPR | Task Priority Register |
| `0x0B0` | EOI | End of Interrupt (write 0 to signal EOI) |
| `0x0F0` | Spurious | Spurious Interrupt Vector Register (bit 8 enables APIC) |
| `0x300` | ICR Low | Interrupt Command Register (low 32 bits) |
| `0x310` | ICR High | Interrupt Command Register (high 32 bits, destination) |
| `0x320` | LVT Timer | Local timer configuration |
| `0x380` | Timer Initial | Timer initial count |
| `0x390` | Timer Current | Timer current count |
| `0x3E0` | Timer Divide | Timer divide configuration |

**I/O APIC:**
- Base address and IRQ routing information found in ACPI MADT table.
- Default base: `0xFEC00000`.
- Two registers: IOREGSEL (offset `0x00`, index select) and IOWIN (offset `0x10`, data window).
- Redirection table entries (64-bit each) map GSIs (Global System Interrupts) to LAPIC vectors.

**Disabling the 8259 PIC when using APIC:**

```c
void pic_disable(void)
{
    outb(0xA1, 0xFF);   /* mask all slave IRQs */
    outb(0x21, 0xFF);   /* mask all master IRQs */
}
```

### PIT (Programmable Interval Timer - Intel 8254)

| Port | Purpose |
|------|---------|
| `0x40` | Channel 0 data (read/write) - connected to IRQ 0 |
| `0x41` | Channel 1 data (read/write) - legacy DRAM refresh |
| `0x42` | Channel 2 data (read/write) - PC speaker |
| `0x43` | Mode/command register (write only) |

Base oscillator frequency: **1,193,182 Hz** (1.193182 MHz).

Divisor formula: `divisor = 1193182 / desired_frequency_hz`

Maximum period: 65536 counts = ~18.2 Hz minimum frequency.

**Initialization for scheduler tick (e.g., 100 Hz):**

```c
void pit_init(uint32_t frequency_hz)
{
    uint16_t divisor = (uint16_t)(1193182 / frequency_hz);

    /* Command: channel 0, access lo/hi byte, mode 3 (square wave), binary */
    outb(0x43, 0x36);

    /* Send divisor low byte then high byte */
    outb(0x40, (uint8_t)(divisor & 0xFF));
    outb(0x40, (uint8_t)((divisor >> 8) & 0xFF));
}
```

Mode/command register byte (port `0x43`):

```
Bits 7-6: Channel select (00 = channel 0)
Bits 5-4: Access mode (11 = lo/hi byte)
Bits 3-1: Mode (011 = mode 3, square wave generator)
Bit  0  : Binary/BCD (0 = 16-bit binary)
```

### Serial UART 16550A

| COM Port | Base I/O | IRQ |
|----------|----------|-----|
| COM1 | `0x3F8` | 4 |
| COM2 | `0x2F8` | 3 |
| COM3 | `0x3E8` | 4 |
| COM4 | `0x2E8` | 3 |

Register offsets from base address:

| Offset | DLAB=0 Read | DLAB=0 Write | DLAB=1 Read/Write |
|--------|-------------|--------------|-------------------|
| +0 | RBR (Receive Buffer) | THR (Transmit Holding) | DLL (Divisor Latch Low) |
| +1 | IER (Interrupt Enable) | IER | DLM (Divisor Latch High) |
| +2 | IIR (Interrupt ID, read) | FCR (FIFO Control, write) | -- |
| +3 | LCR (Line Control) | LCR | -- |
| +4 | MCR (Modem Control) | MCR | -- |
| +5 | LSR (Line Status) | -- | -- |
| +6 | MSR (Modem Status) | -- | -- |
| +7 | Scratch Register | Scratch Register | -- |

LSR (Line Status Register, offset +5) key bits:
- Bit 0: Data Ready (DR) - received data available
- Bit 5: Transmitter Holding Register Empty (THRE) - can send
- Bit 6: Transmitter Empty (TEMT) - shift register empty

**Initialization (115200 baud, 8N1):**

```c
#define COM1 0x3F8

void serial_init(void)
{
    outb(COM1 + 1, 0x00);   /* Disable all interrupts */
    outb(COM1 + 3, 0x80);   /* Enable DLAB (set baud rate divisor) */
    outb(COM1 + 0, 0x01);   /* Divisor low byte: 115200 baud (divisor = 1) */
    outb(COM1 + 1, 0x00);   /* Divisor high byte */
    outb(COM1 + 3, 0x03);   /* 8 bits, no parity, 1 stop bit (8N1), DLAB off */
    outb(COM1 + 2, 0xC7);   /* Enable FIFO, clear TX/RX, 14-byte threshold */
    outb(COM1 + 4, 0x0B);   /* IRQs enabled, RTS/DSR set, OUT2 set */
}

void serial_putchar(char c)
{
    /* Wait until transmit holding register is empty */
    while ((inb(COM1 + 5) & 0x20) == 0)
        ;
    outb(COM1, c);
}

char serial_getchar(void)
{
    /* Wait until data is ready */
    while ((inb(COM1 + 5) & 0x01) == 0)
        ;
    return inb(COM1);
}
```

Baud rate divisor: `divisor = 115200 / desired_baud`. For 115200 baud, divisor = 1. For 9600 baud, divisor = 12.

### VGA Text Mode

| Parameter | Value |
|-----------|-------|
| Framebuffer address | `0xB8000` (physical) |
| Columns | 80 |
| Rows | 25 |
| Bytes per character | 2 (character byte + attribute byte) |
| Total framebuffer size | 80 * 25 * 2 = 4000 bytes |

Character cell format (2 bytes, little-endian):

```
Byte 0: ASCII character code
Byte 1: Attribute byte
  Bits 0-3: Foreground color
  Bits 4-6: Background color
  Bit  7:   Blink (or high-intensity background, depending on mode)
```

Standard VGA color palette:

| Value | Color | Value | Color (bright) |
|-------|-------|-------|-----------------|
| 0x0 | Black | 0x8 | Dark Grey |
| 0x1 | Blue | 0x9 | Light Blue |
| 0x2 | Green | 0xA | Light Green |
| 0x3 | Cyan | 0xB | Light Cyan |
| 0x4 | Red | 0xC | Light Red |
| 0x5 | Magenta | 0xD | Light Magenta |
| 0x6 | Brown | 0xE | Yellow |
| 0x7 | Light Grey | 0xF | White |

```c
#define VGA_BASE    0xB8000
#define VGA_COLS    80
#define VGA_ROWS    25

void vga_putchar(int x, int y, char c, uint8_t attr)
{
    volatile uint16_t *vga = (volatile uint16_t *)VGA_BASE;
    vga[y * VGA_COLS + x] = (uint16_t)c | ((uint16_t)attr << 8);
}
```

VGA cursor control via I/O ports `0x3D4` (index) and `0x3D5` (data):
- Register `0x0E`: Cursor location high byte
- Register `0x0F`: Cursor location low byte

### PS/2 Keyboard Controller

| Port | Purpose |
|------|---------|
| `0x60` | Data port (read: scancode, write: command to device) |
| `0x64` | Status register (read) / Command register (write) |

Status register (port `0x64`, read) bits:
- Bit 0: Output buffer full (data available to read from `0x60`)
- Bit 1: Input buffer full (controller busy, wait before writing)
- Bit 2: System flag (set after self-test pass)
- Bit 5: Output buffer from mouse (if bit 0 also set)

IRQ: **IRQ 1** (vector 33 after PIC remap).

Scan code set 1 (default): Key press generates a make code; key release generates the same code OR'd with `0x80` (break code). Extended keys are prefixed with `0xE0`.

```c
uint8_t keyboard_read_scancode(void)
{
    /* Wait for output buffer to be full */
    while ((inb(0x64) & 0x01) == 0)
        ;
    return inb(0x60);
}
```

---

## Firmware

### ACPI (Advanced Configuration and Power Interface)

x86_64 systems use ACPI for hardware enumeration and power management. No Device Tree support.

**RSDP (Root System Description Pointer) discovery:**

1. Search physical memory range `0x000E0000` - `0x000FFFFF` for signature `"RSD PTR "` (8 bytes, note trailing space).
2. Alternatively, for UEFI systems, the RSDP address is provided by the EFI System Table (or via Multiboot2 ACPI tags: tag type 14 for ACPI 1.0, tag type 15 for ACPI 2.0+).
3. The signature must be aligned on a 16-byte boundary.
4. Validate checksum: sum of all bytes in the RSDP structure must equal zero (mod 256).

**RSDP structure (ACPI 1.0, 20 bytes):**

```c
typedef struct acpi_rsdp {
    char     signature[8];      /* "RSD PTR " */
    uint8_t  checksum;          /* sum of first 20 bytes = 0 */
    char     oem_id[6];
    uint8_t  revision;          /* 0 = ACPI 1.0, 2 = ACPI 2.0+ */
    uint32_t rsdt_address;      /* physical address of RSDT (32-bit) */
} __attribute__((packed)) acpi_rsdp_t;
```

**RSDP structure (ACPI 2.0+, 36 bytes, extends above):**

```c
typedef struct acpi_rsdp2 {
    acpi_rsdp_t base;
    uint32_t    length;         /* length of entire RSDP (36) */
    uint64_t    xsdt_address;   /* physical address of XSDT (64-bit) */
    uint8_t     ext_checksum;   /* checksum of entire structure */
    uint8_t     reserved[3];
} __attribute__((packed)) acpi_rsdp2_t;
```

**Table hierarchy:**

```
RSDP
 ├── RSDT (32-bit table pointers, ACPI 1.0)
 │    ├── MADT    (Multiple APIC Description Table)
 │    ├── FADT    (Fixed ACPI Description Table)
 │    ├── MCFG    (PCI Express ECAM base)
 │    ├── HPET    (High Precision Event Timer)
 │    └── ...
 └── XSDT (64-bit table pointers, ACPI 2.0+)
      └── (same tables as RSDT, but pointers are 64-bit)
```

**Common ACPI SDT header (shared by all tables):**

```c
typedef struct acpi_sdt_header {
    char     signature[4];      /* e.g., "APIC", "FACP", "MCFG" */
    uint32_t length;            /* total table length including header */
    uint8_t  revision;
    uint8_t  checksum;          /* sum of all bytes = 0 */
    char     oem_id[6];
    char     oem_table_id[8];
    uint32_t oem_revision;
    uint32_t creator_id;
    uint32_t creator_revision;
} __attribute__((packed)) acpi_sdt_header_t;
```

### Key ACPI Tables

**MADT (signature `"APIC"`):** Lists all interrupt controllers.

Entry types:
| Type | Structure | Description |
|------|-----------|-------------|
| 0 | Processor Local APIC | One per CPU core: ACPI processor ID, APIC ID, flags |
| 1 | I/O APIC | I/O APIC ID, base address, GSI base |
| 2 | Interrupt Source Override | Remaps ISA IRQs to different GSIs (e.g., IRQ 0 -> GSI 2) |
| 4 | Local APIC NMI | NMI delivery to a specific LAPIC |
| 5 | Local APIC Address Override | 64-bit override of LAPIC base address |

**FADT (signature `"FACP"`):** Fixed ACPI Description Table. Contains power management port addresses, SCI interrupt number, and pointer to DSDT.

**MCFG (signature `"MCFG"`):** PCIe memory-mapped configuration space. Contains the ECAM base address, start bus number, and end bus number for each PCI segment.

---

## Context Switch Assembly

The context switch saves and restores callee-saved registers only. The System V ABI guarantees that a function call preserves RBX, RBP, R12-R15 and RFLAGS direction flag. Since `arch_context_switch` is called from C, all caller-saved registers are already saved by the compiler on the caller's stack.

### Complete Implementation (`context_switch.asm`)

```nasm
; =============================================================================
; arch_context_switch(uint64_t *old_sp_ptr, uint64_t new_sp)
;
; Arguments (System V AMD64 ABI):
;   RDI = pointer to old process's saved stack pointer (uint64_t *old_sp_ptr)
;   RSI = new process's stack pointer value (uint64_t new_sp)
;
; Saves the current context by pushing callee-saved registers onto the
; current stack, stores the current RSP into *old_sp_ptr, loads new_sp
; into RSP, and restores the new process's callee-saved registers.
;
; On return, execution continues in the new process at the point where
; it previously called arch_context_switch.
; =============================================================================

global arch_context_switch
arch_context_switch:
    ; --- Save current process state ---
    ; Push callee-saved registers
    push rbx
    push rbp
    push r12
    push r13
    push r14
    push r15

    ; Push RFLAGS
    pushfq

    ; Save current stack pointer to *old_sp_ptr
    mov [rdi], rsp

    ; --- Load new process state ---
    ; Switch to new stack
    mov rsp, rsi

    ; Restore RFLAGS
    popfq

    ; Restore callee-saved registers
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbp
    pop rbx

    ; Return to the new process's caller
    ; (the return address is on the new stack from when it called this function)
    ret
```

### Stack Frame After Save

When a process is suspended inside `arch_context_switch`, its stack looks like:

```
High address (stack bottom)
  ...
  [return address]      <- pushed by CALL to arch_context_switch
  [RBX]
  [RBP]
  [R12]
  [R13]
  [R14]
  [R15]
  [RFLAGS]              <- RSP points here (saved to *old_sp_ptr)
Low address (stack top)
```

### Initial Context Setup

For a newly created process that has never run, the kernel builds a fake stack frame so that the first `arch_context_switch` into the process will "return" to the process's entry point:

```c
void arch_setup_initial_context(struct process *proc, void (*entry)(void))
{
    uint64_t *sp = (uint64_t *)(proc->kernel_stack + ARCH_STACK_SIZE);

    /* Build fake context_switch frame */
    *(--sp) = (uint64_t)entry;   /* return address: process entry point */
    *(--sp) = 0;                 /* RBX */
    *(--sp) = 0;                 /* RBP */
    *(--sp) = 0;                 /* R12 */
    *(--sp) = 0;                 /* R13 */
    *(--sp) = 0;                 /* R14 */
    *(--sp) = 0;                 /* R15 */
    *(--sp) = 0x200;             /* RFLAGS: IF=1 (interrupts enabled) */

    proc->saved_sp = (uint64_t)sp;
}
```

---

## Initial Page Table Setup

This assembly sets up the minimum page tables required to boot into C code: an identity map of the first 2MB at physical address 0, plus the same 2MB mapped at `KERNEL_VBASE` (`0xFFFF800000000000`). Both use a single 2MB huge page at PD level.

```nasm
; =============================================================================
; Initial page table setup for boot
;
; Maps:
;   Virtual 0x0000_0000_0000_0000 (2MB) -> Physical 0x0 (identity, for boot code)
;   Virtual 0xFFFF_8000_0000_0000 (2MB) -> Physical 0x0 (higher-half kernel)
;
; Uses 2MB huge pages (PD level, bit 7 set) to avoid needing a PT.
;
; PML4 index for 0x0000000000000000:   (0x0000000000000000 >> 39) & 0x1FF = 0
; PML4 index for 0xFFFF800000000000:   (0xFFFF800000000000 >> 39) & 0x1FF = 256
; PDPT index for both:                 0
; PD index for both:                   0
; =============================================================================

section .bss
align 4096
boot_pml4:      resb 4096       ; Page Map Level 4
boot_pdpt:      resb 4096       ; Page Directory Pointer Table
boot_pd:        resb 4096       ; Page Directory

section .text
bits 32

setup_page_tables:
    ; Zero all page table pages
    mov edi, boot_pml4
    xor eax, eax
    mov ecx, (4096 * 3) / 4    ; 3 pages, 4 bytes per stosd
    rep stosd

    ; PML4[0] -> boot_pdpt | PRESENT | WRITABLE
    mov eax, boot_pdpt
    or  eax, 0x03
    mov [boot_pml4], eax

    ; PML4[256] -> boot_pdpt | PRESENT | WRITABLE  (higher-half)
    mov [boot_pml4 + 256 * 8], eax

    ; PDPT[0] -> boot_pd | PRESENT | WRITABLE
    mov eax, boot_pd
    or  eax, 0x03
    mov [boot_pdpt], eax

    ; PD[0] -> 2MB huge page at physical 0x0
    ; Flags: PRESENT (bit 0) | WRITABLE (bit 1) | HUGE (bit 7) = 0x83
    mov dword [boot_pd], 0x00000083
    mov dword [boot_pd + 4], 0x00000000   ; high 32 bits of address = 0

    ; Load PML4 into CR3
    mov eax, boot_pml4
    mov cr3, eax

    ret
```

After the kernel is in long mode and `vmm_init()` runs, these boot page tables are replaced with properly managed page tables that map the full kernel image, heap, and device regions.

---

## Interrupt Handling Assembly

IDT stub handlers push a uniform stack frame and call a common C dispatcher:

```nasm
; =============================================================================
; IDT stub macros and common handler
; =============================================================================

; Macro for exceptions that do NOT push an error code
%macro ISR_NOERRCODE 1
global isr_%1
isr_%1:
    push 0              ; push dummy error code for uniform frame
    push %1             ; push interrupt vector number
    jmp isr_common
%endmacro

; Macro for exceptions that DO push an error code (CPU pushes it automatically)
%macro ISR_ERRCODE 1
global isr_%1
isr_%1:
    push %1             ; push interrupt vector number (error code already on stack)
    jmp isr_common
%endmacro

; --- Exception stubs (vectors 0-31) ---
ISR_NOERRCODE 0     ; #DE Division Error
ISR_NOERRCODE 1     ; #DB Debug
ISR_NOERRCODE 2     ; NMI
ISR_NOERRCODE 3     ; #BP Breakpoint
ISR_NOERRCODE 4     ; #OF Overflow
ISR_NOERRCODE 5     ; #BR Bound Range
ISR_NOERRCODE 6     ; #UD Invalid Opcode
ISR_NOERRCODE 7     ; #NM Device Not Available
ISR_ERRCODE   8     ; #DF Double Fault
ISR_NOERRCODE 9     ; Coprocessor Segment Overrun
ISR_ERRCODE   10    ; #TS Invalid TSS
ISR_ERRCODE   11    ; #NP Segment Not Present
ISR_ERRCODE   12    ; #SS Stack Fault
ISR_ERRCODE   13    ; #GP General Protection Fault
ISR_ERRCODE   14    ; #PF Page Fault
ISR_NOERRCODE 15    ; Reserved
ISR_NOERRCODE 16    ; #MF x87 FPU Exception
ISR_ERRCODE   17    ; #AC Alignment Check
ISR_NOERRCODE 18    ; #MC Machine Check
ISR_NOERRCODE 19    ; #XM SIMD Exception
ISR_NOERRCODE 20    ; #VE Virtualization Exception
ISR_ERRCODE   21    ; #CP Control Protection
; vectors 22-31: reserved
%assign i 22
%rep 10
ISR_NOERRCODE i
%assign i i+1
%endrep

; --- IRQ stubs (vectors 32-47) ---
%assign i 32
%rep 16
ISR_NOERRCODE i
%assign i i+1
%endrep

; --- Remaining vectors (48-255) ---
%assign i 48
%rep 208
ISR_NOERRCODE i
%assign i i+1
%endrep

; =============================================================================
; Common ISR handler
; =============================================================================
extern interrupt_dispatch   ; void interrupt_dispatch(interrupt_frame_t *frame)

isr_common:
    ; Save all general-purpose registers
    push rax
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi
    push rbp
    push r8
    push r9
    push r10
    push r11
    push r12
    push r13
    push r14
    push r15

    ; Pass pointer to this stack frame as argument (RDI)
    mov rdi, rsp
    call interrupt_dispatch

    ; Restore all general-purpose registers
    pop r15
    pop r14
    pop r13
    pop r12
    pop r11
    pop r10
    pop r9
    pop r8
    pop rbp
    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    pop rax

    ; Remove vector number and error code from stack
    add rsp, 16

    ; Return from interrupt
    iretq
```

**Interrupt frame structure (matches stack layout):**

```c
typedef struct interrupt_frame {
    /* Pushed by isr_common (in reverse order) */
    uint64_t r15, r14, r13, r12, r11, r10, r9, r8;
    uint64_t rbp, rdi, rsi, rdx, rcx, rbx, rax;
    /* Pushed by ISR stub */
    uint64_t vector;
    uint64_t error_code;
    /* Pushed by CPU on interrupt */
    uint64_t rip;
    uint64_t cs;
    uint64_t rflags;
    uint64_t rsp;
    uint64_t ss;
} __attribute__((packed)) interrupt_frame_t;
```

---

## QEMU Test Command

Primary test command (headless, serial output to terminal):

```
qemu-system-x86_64 -kernel kernel.bin -serial stdio -display none -no-reboot -m 128M
```

| Flag | Purpose |
|------|---------|
| `-kernel kernel.bin` | Load ELF kernel directly (QEMU provides Multiboot2 header support) |
| `-serial stdio` | Route COM1 serial output to the host terminal |
| `-display none` | No graphical window (headless operation) |
| `-no-reboot` | On triple fault or shutdown, exit QEMU instead of rebooting |
| `-m 128M` | Allocate 128 MB of guest RAM |

Additional useful QEMU flags for development:

```bash
# Enable GDB debugging (halt at boot, connect with gdb on port 1234)
qemu-system-x86_64 -kernel kernel.bin -serial stdio -display none -no-reboot -m 128M \
    -s -S

# With an initramfs module
qemu-system-x86_64 -kernel kernel.bin -serial stdio -display none -no-reboot -m 128M \
    -initrd initramfs.img

# With VGA text mode output visible
qemu-system-x86_64 -kernel kernel.bin -serial stdio -no-reboot -m 128M

# Enable interrupt logging for debugging
qemu-system-x86_64 -kernel kernel.bin -serial stdio -display none -no-reboot -m 128M \
    -d int,cpu_reset -D qemu_log.txt

# With virtio-net for networking tests
qemu-system-x86_64 -kernel kernel.bin -serial stdio -display none -no-reboot -m 128M \
    -netdev user,id=net0 -device virtio-net-pci,netdev=net0
```

---

## Acceptance Criteria

These are the x86_64-specific boot tests that must pass before the architecture port is considered functional:

### 1. Multiboot2 Magic Validation
- **Test:** Boot in QEMU. The kernel must detect EAX == `0x36D76289` and proceed.
- **Negative test:** Patch EAX to wrong value before the check. Kernel must halt with serial output: `"FATAL: Invalid Multiboot2 magic"`.
- **Verification:** Serial output includes `"AUTON Kernel booting..."` (only printed after magic validation succeeds).

### 2. Long Mode Enabled
- **Test:** After `_start64` is reached, read MSR `0xC0000080` and verify bit 10 (LMA, Long Mode Active) is set.
- **Verification:** Print EFER register value to serial. `EFER.LMA == 1`.
- **Test:** Execute a 64-bit instruction (`mov rax, 0xDEAD_BEEF_CAFE_BABE`) and verify RAX contains the full 64-bit value.

### 3. 64-bit GDT Loaded
- **Test:** After `gdt_init()`, execute `sgdt` to read the GDT pointer. Verify:
  - GDT limit >= 47 (6 entries * 8 bytes - 1, minimum; TSS entry is 16 bytes so limit >= 55).
  - GDT base is a valid kernel address.
- **Test:** Verify CS selector is `0x08` (kernel code segment) using inline assembly.
- **Test:** Verify DS, ES, SS selectors are `0x10` (kernel data segment).

### 4. IDT Loaded
- **Test:** After `idt_init()`, execute `sidt` to read the IDT pointer. Verify:
  - IDT limit == 256 * 16 - 1 == 4095.
  - IDT base is a valid kernel address.
- **Test:** Trigger a deliberate division by zero (`int x = 1/0;`). Verify the #DE exception handler fires and prints diagnostic to serial: vector number, RIP, error code.
- **Test:** Trigger a deliberate page fault by reading from an unmapped address. Verify #PF handler fires with correct CR2.

### 5. Page Tables Functional
- **Test:** Write a known value to a virtual address. Read it back. Values match.
- **Test:** Verify identity map: virtual address `0x0000_0000_000B_8000` accesses VGA framebuffer (write character, read back from physical VGA buffer).
- **Test:** Verify higher-half map: access kernel code through `KERNEL_VBASE + offset` produces correct instruction bytes.

### 6. PIC Remapped
- **Test:** After `pic_init()`, trigger a PIT timer interrupt. Verify it arrives at vector 32 (not vector 0).
- **Test:** Press a key on the PS/2 keyboard. Verify IRQ arrives at vector 33.

### 7. Serial Output Functional
- **Test:** `serial_putchar('A')` followed by `serial_putchar('\n')`. Verify QEMU `-serial stdio` shows "A\n" on the host terminal.

### 8. Timer Ticking
- **Test:** After `pit_init(100)`, verify the timer ISR at vector 32 fires. Increment a global counter in the ISR. After a short busy-wait, counter > 0.

### 9. Full Boot Sequence
- **Test:** Boot the complete kernel in QEMU. Serial output must show (in order):
  1. `"AUTON Kernel booting..."`
  2. Memory map parsed (total RAM printed)
  3. GDT initialized
  4. IDT initialized
  5. PMM initialized (free pages printed)
  6. VMM initialized
  7. Slab allocator initialized
  8. Timer started
  9. Scheduler initialized
  10. SLM runtime initialized
- **Verification:** No panic messages. No triple faults (QEMU does not reset).

---

## Reference: Key MSRs

| MSR Number | Name | Key Bits |
|------------|------|----------|
| `0xC0000080` | IA32_EFER | SCE(0), LME(8), LMA(10), NXE(11) |
| `0xC0000081` | IA32_STAR | SYSCALL target CS/SS (bits 47:32), SYSRET CS/SS (bits 63:48) |
| `0xC0000082` | IA32_LSTAR | SYSCALL entry point (64-bit RIP) |
| `0xC0000084` | IA32_FMASK | RFLAGS mask for SYSCALL |
| `0x0000001B` | IA32_APIC_BASE | APIC base address (bits 12-35), enable bit (11), BSP flag (8) |
| `0x00000277` | IA32_PAT | Page Attribute Table configuration |

### Reading/Writing MSRs

```c
static inline uint64_t rdmsr(uint32_t msr)
{
    uint32_t lo, hi;
    __asm__ volatile("rdmsr" : "=a"(lo), "=d"(hi) : "c"(msr));
    return ((uint64_t)hi << 32) | lo;
}

static inline void wrmsr(uint32_t msr, uint64_t val)
{
    __asm__ volatile("wrmsr" : : "c"(msr), "a"((uint32_t)val), "d"((uint32_t)(val >> 32)));
}
```

---

## Reference: CPUID

The `CPUID` instruction is used for CPU feature detection. Set EAX (and sometimes ECX) before calling, results in EAX/EBX/ECX/EDX.

| EAX Input | Returns |
|-----------|---------|
| `0x00000000` | Max basic leaf (EAX), vendor string (EBX/EDX/ECX) |
| `0x00000001` | Family/model/stepping (EAX), features (ECX/EDX): SSE, SSE2, APIC, MSR, PAE, etc. |
| `0x80000000` | Max extended leaf (EAX) |
| `0x80000001` | Extended features (ECX/EDX): NX bit (EDX bit 20), Long Mode (EDX bit 29), 1GB pages (EDX bit 26) |

```c
static inline void cpuid(uint32_t leaf, uint32_t *eax, uint32_t *ebx,
                          uint32_t *ecx, uint32_t *edx)
{
    __asm__ volatile("cpuid"
        : "=a"(*eax), "=b"(*ebx), "=c"(*ecx), "=d"(*edx)
        : "a"(leaf), "c"(0));
}
```

**Critical checks at boot:**
- Long Mode support: `CPUID(0x80000001)`, EDX bit 29 must be set.
- NX bit support: `CPUID(0x80000001)`, EDX bit 20 (enable via EFER.NXE).
- APIC present: `CPUID(0x00000001)`, EDX bit 9.
- 1GB huge pages: `CPUID(0x80000001)`, EDX bit 26 (optional optimization).
