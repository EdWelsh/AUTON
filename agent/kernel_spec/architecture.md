# AUTON Kernel Architecture

## Overview

AUTON is a custom x86_64 kernel that functions as a natural language LLM agent-based hypervisor. Its primary innovation is replacing traditional syscall interfaces with a natural language processing layer, enabling agents (processes) to communicate with the kernel using human-readable instructions.

## Target Platform

- **Architecture**: x86_64 (AMD64)
- **Boot Protocol**: Multiboot2 (GRUB-compatible)
- **Test Platform**: QEMU (`qemu-system-x86_64`)
- **Language**: C11 (kernel) + NASM x86_64 Assembly (boot, interrupts, context switch)
- **Compiler**: `x86_64-elf-gcc` cross-compiler
- **Assembler**: `nasm`

## Memory Layout

```
0x0000_0000_0000_0000 - 0x0000_7FFF_FFFF_FFFF  User space (agent VMs)
0xFFFF_8000_0000_0000 - 0xFFFF_FFFF_FFFF_FFFF  Kernel space

Kernel Physical Layout:
0x0010_0000 (1 MB)     Kernel load address
0x0020_0000 (2 MB)     Kernel heap start
0x0040_0000 (4 MB)     Agent VM memory pool start
```

## Subsystems

### 1. Boot (`kernel/boot/`)
- Multiboot2 header and entry point
- GDT (Global Descriptor Table) setup for 64-bit mode
- IDT (Interrupt Descriptor Table) with exception handlers
- Transition: real mode → protected mode → long mode
- Stack setup and BSS clearing
- Jump to C `kernel_main()`

### 2. Memory Management (`kernel/mm/`)
- **Physical Memory Manager (PMM)**: Bitmap-based page allocator (4KB pages)
- **Virtual Memory Manager (VMM)**: 4-level paging (PML4 → PDPT → PD → PT)
- **Slab Allocator**: kmalloc/kfree for kernel objects
- Memory map parsed from Multiboot2 info

### 3. Scheduler (`kernel/sched/`)
- Preemptive round-robin with priority classes
- Priority levels: KERNEL > SYSTEM_AGENT > USER_AGENT > BACKGROUND
- Timer interrupt (PIT or APIC) drives preemption
- Context switching via assembly (save/restore registers + stack)
- Agent-aware: LLM inference tasks get higher priority

### 4. Inter-Process Communication (`kernel/ipc/`)
- Message-passing IPC (not shared memory for security)
- Messages are natural language strings (UTF-8)
- Ring buffer per agent pair
- Blocking and non-blocking send/receive

### 5. Natural Language Syscall Interface (`kernel/nl_syscall/`)
- Agents issue "syscalls" as natural language strings
- NL parser maps intent to kernel operations:
  - "allocate 4KB of memory" → pmm_alloc_page()
  - "send message to agent-2: hello" → ipc_send(2, "hello")
  - "list running agents" → sched_list_processes()
- Fallback: traditional numeric syscall interface for bootstrapping

### 6. Hypervisor (`kernel/hypervisor/`)
- Each agent runs in an isolated VM (separate page tables)
- Capability-based security: agents hold capability tokens
- Capabilities: MEMORY, IPC, SPAWN, NL_SYSCALL, DEVICE
- Agent lifecycle: create → start → suspend → resume → destroy

### 7. Drivers (`kernel/drivers/`)
- **Serial**: UART 16550A (COM1) for console I/O
- **VGA Text**: 80x25 text mode framebuffer
- **Timer**: PIT (8254) for scheduler tick
- **Keyboard**: PS/2 keyboard for input
- **Virtio**: Guest driver for QEMU (future: network, block)

### 8. LLM Runtime (`kernel/llm/`)
- Lightweight inference engine for natural language parsing
- Initially: pattern matching + keyword extraction
- Future: embedded small model (TinyLLM) for actual NL understanding
- Tokenizer, intent classifier, entity extractor

## Build System

```makefile
# Toolchain
CC = x86_64-elf-gcc
AS = nasm
LD = x86_64-elf-ld

# Flags
CFLAGS = -ffreestanding -mno-red-zone -fno-exceptions -fno-rtti -Wall -Wextra -std=c11
ASFLAGS = -f elf64
LDFLAGS = -T linker.ld -nostdlib

# Targets
all: kernel.bin
kernel.bin: boot.o kernel.o mm.o sched.o ipc.o nl_syscall.o hypervisor.o drivers.o llm.o
	$(LD) $(LDFLAGS) -o $@ $^
```

## Directory Structure (generated by agents)

```
kernel/
├── boot/           # Assembly boot code, GDT, IDT
├── mm/             # Physical + virtual memory management
├── sched/          # Process scheduler
├── ipc/            # Inter-process communication
├── nl_syscall/     # Natural language syscall interface
├── hypervisor/     # Agent VM management
├── drivers/        # Device drivers
├── llm/            # NL inference runtime
├── include/        # Header files (interfaces)
├── lib/            # Utility functions (string, printf)
├── Makefile        # Build rules
└── linker.ld       # Linker script
```

## Coding Standards

- Linux kernel style: tabs for indentation, K&R braces
- 80-column soft limit, 100-column hard limit
- Every exported function has a prototype in a header file
- All memory allocations must have corresponding frees
- No dynamic memory allocation in interrupt handlers
- Use `static` for file-scoped functions
- Comments for non-obvious logic, not for self-evident code
