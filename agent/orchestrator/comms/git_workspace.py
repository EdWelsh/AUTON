"""Git workspace management for agent collaboration."""

from __future__ import annotations

import logging
import os
import shutil
from pathlib import Path

import git as _git

# Configure GitPython to find git executable on Windows
_git_exe = shutil.which("git")
if not _git_exe:
    # Common Windows locations
    for candidate in [
        r"C:\Program Files\Git\bin\git.exe",
        r"C:\Program Files\Git\cmd\git.exe",
        r"C:\Program Files (x86)\Git\bin\git.exe",
    ]:
        if os.path.isfile(candidate):
            _git_exe = candidate
            break
if _git_exe:
    _git.refresh(_git_exe)

from git import Repo
from git.exc import GitCommandError, InvalidGitRepositoryError, NoSuchPathError

logger = logging.getLogger(__name__)


class GitWorkspace:
    """Manages the shared git repository where agents write kernel code.

    Each agent works on a feature branch. The Integrator merges approved
    branches into main. Communication happens through branch state and
    metadata files in .auton/.
    """

    def __init__(self, workspace_path: Path, branch_prefix: str = "agent"):
        self.path = workspace_path.resolve()
        self.branch_prefix = branch_prefix
        self._repo: Repo | None = None

    @property
    def repo(self) -> Repo:
        if self._repo is None:
            raise RuntimeError("Workspace not initialized. Call init() first.")
        return self._repo

    def init(self) -> None:
        """Initialize or open the workspace git repository."""
        try:
            self._repo = Repo(self.path)
            logger.info("Opened existing workspace at %s", self.path)
        except (InvalidGitRepositoryError, NoSuchPathError):
            self.path.mkdir(parents=True, exist_ok=True)
            self._repo = Repo.init(self.path)
            # Create initial commit so branches work
            readme = self.path / "README.md"
            readme.write_text("# AUTON Kernel Workspace\n\nGenerated by AUTON agents.\n")
            self._repo.index.add(["README.md"])
            self._repo.index.commit("Initial commit")
            # Create .auton metadata directory
            auton_dir = self.path / ".auton"
            auton_dir.mkdir(exist_ok=True)
            (auton_dir / "tasks").mkdir(exist_ok=True)
            (auton_dir / "messages").mkdir(exist_ok=True)
            self._repo.index.add([".auton"])
            self._repo.index.commit("Add .auton metadata directory")
            logger.info("Initialized new workspace at %s", self.path)

    def create_branch(self, agent_id: str, subsystem: str, component: str) -> str:
        """Create a feature branch for an agent's task.

        Returns the branch name.
        """
        branch_name = f"{self.branch_prefix}/{agent_id}/{subsystem}-{component}"
        if branch_name in [b.name for b in self.repo.branches]:
            logger.info("Branch %s already exists, checking out", branch_name)
            self.repo.git.checkout(branch_name)
        else:
            self.repo.git.checkout("-b", branch_name)
            logger.info("Created branch %s", branch_name)
        return branch_name

    def checkout(self, branch: str) -> None:
        """Switch to a branch."""
        self.repo.git.checkout(branch)

    def checkout_main(self) -> None:
        """Switch back to main branch."""
        main = self._get_main_branch()
        self.repo.git.checkout(main)

    def read_file(self, path: str) -> str:
        """Read a file from the workspace."""
        full_path = self.path / path
        if not full_path.exists():
            raise FileNotFoundError(f"File not found: {path}")
        return full_path.read_text(encoding="utf-8")

    def write_file(self, path: str, content: str) -> None:
        """Write a file to the workspace, creating parent directories."""
        full_path = self.path / path
        full_path.parent.mkdir(parents=True, exist_ok=True)
        full_path.write_text(content, encoding="utf-8")

    def list_files(self, path: str = ".", recursive: bool = False) -> list[str]:
        """List files in a workspace directory."""
        full_path = self.path / path
        if not full_path.is_dir():
            return []
        if recursive:
            return [
                str(p.relative_to(self.path))
                for p in full_path.rglob("*")
                if p.is_file() and ".git" not in p.parts
            ]
        return [
            str(p.relative_to(self.path))
            for p in full_path.iterdir()
            if p.is_file() and ".git" not in p.parts
        ]

    def search_code(self, pattern: str, glob: str = "*") -> list[dict]:
        """Search workspace files for a pattern."""
        import re

        results = []
        for path in self.path.rglob(glob):
            if not path.is_file() or ".git" in path.parts:
                continue
            try:
                content = path.read_text(encoding="utf-8")
                for i, line in enumerate(content.splitlines(), 1):
                    if re.search(pattern, line):
                        results.append(
                            {
                                "file": str(path.relative_to(self.path)),
                                "line": i,
                                "content": line.strip(),
                            }
                        )
            except (UnicodeDecodeError, PermissionError):
                continue
        return results

    def commit(self, message: str, files: list[str] | None = None) -> str:
        """Stage and commit changes. Returns the commit hash."""
        if files:
            self.repo.index.add(files)
        else:
            self.repo.git.add("-A")

        if not self.repo.index.diff("HEAD") and not self.repo.untracked_files:
            logger.info("Nothing to commit")
            return self.repo.head.commit.hexsha

        commit = self.repo.index.commit(message)
        logger.info("Committed %s: %s", commit.hexsha[:8], message)
        return commit.hexsha

    def diff(self, branch: str | None = None) -> str:
        """Get diff of current changes or against a branch."""
        if branch:
            return self.repo.git.diff(branch)
        return self.repo.git.diff()

    def get_branch_status(self) -> dict[str, dict]:
        """Get the status of all agent branches."""
        main = self._get_main_branch()
        status = {}
        for branch in self.repo.branches:
            if branch.name == main:
                continue
            ahead = len(
                list(self.repo.iter_commits(f"{main}..{branch.name}"))
            )
            status[branch.name] = {
                "ahead": ahead,
                "last_commit": branch.commit.message.strip(),
                "last_author": str(branch.commit.author),
                "last_date": branch.commit.committed_datetime.isoformat(),
            }
        return status

    def merge_branch(self, branch: str) -> bool:
        """Merge a branch into main. Returns True if successful."""
        main = self._get_main_branch()
        self.repo.git.checkout(main)
        try:
            self.repo.git.merge(branch, "--no-ff", "-m", f"Merge {branch}")
            logger.info("Merged %s into %s", branch, main)
            return True
        except GitCommandError as e:
            logger.error("Merge conflict merging %s: %s", branch, e)
            self.repo.git.merge("--abort")
            return False

    def _get_main_branch(self) -> str:
        """Get the name of the main branch."""
        for name in ("main", "master"):
            if name in [b.name for b in self.repo.branches]:
                return name
        return "main"
